\documentclass[dvips,xcolor=pst,color=usenames]{beamer}

\usetheme{Madrid}
\usepackage{url}
\usepackage{pstricks}
\usepackage{pst-tree}
\usepackage{pst-node}
\usepackage{proof}
\usepackage{pst-grad}
\usepackage{fancyvrb}

\setbeamertemplate{navigation symbols}{}
\setbeamercolor{math text}{fg=blue}
\newcommand{\structcol}{\usebeamercolor[fg]{structure}}

\title[Formally Defining C++]{Formally Defining C++\\
  Why, How, \& What Exactly}
\author{Michael Norrish}
\institute{National ICT Australia}
\titlegraphic{\includegraphics[width=0.3\textwidth]{nicta-colour-on-pale.eps}}
\date{25 April 2006}

\begin{document}

\frame{\titlepage}

\section{Introduction}

\section{Why?}
\frame{
  \frametitle{Why Describe a Language?}

\textbf{Reason \#1:}

\begin{quote}
To establish a contract between the {\red users} and
{\red implementors} of a language
\end{quote}

\pause
\begin{center}
\begin{tabular}{lp{0.6\textwidth}}
{\structcol Users} & Programmers; those who submit source code to a language
  implementation and expect a particular behaviour in return\\[3mm]
{\structcol Implementors} & Programmers; those who write a language
  implementation which other programmers will feed with source code
\end{tabular}
\end{center}

}

\frame{
  \frametitle{A Language Contract}

{\structcol \bfseries Manages Expectations}

\begin{itemize}
\item Users expect \texttt{\structcol i = i + 1} to add one to
  variable \texttt{\structcol i}

\item Implementors can rely on users not attempting to divide by
  zero (in C/C++ anyway)
\end{itemize}

\pause
\bigskip\bigskip
{\structcol \bfseries Is Not an Implementation}

\begin{itemize}
\item Even for a language like Perl.
  \begin{itemize}
  \item After all, people report bugs
    against Perl implementations.   Something other than the
    implementation is defining what is and is not correct.
  \end{itemize}
\end{itemize}

}

\frame{
  \frametitle{Language Contracts are Written in English}

To wit (ISO/IEC 14882:2003, \S3.5, para 8):
\begin{quote}
\small
Names not covered by these rules have no linkage.  Moreover, except as
noted, a name declared in a local scope (3.3.2) has no linkage.  A
name with no linkage (notably, the name of a class or enumeration
declared in a local scope (3.3.2)) shall not be used to declare an
entity with linkage.  If a declaration uses a typedef name, it is the
linkage of the type name to which the typedef refers that is
considered. [Example: ...] This implies that names with no linkage
cannot be used as template arguments (14.3).
\end{quote}

If the user and the implementor disagree on the meaning of the
contract, how can such a dispute be resolved?

}

\frame{
  \frametitle{Formal Contracts}

  [``Formal'' $=$ ``Mathematical'']

  \medskip
  \begin{itemize}
  \item Mathematical reasoning is a route to certainty
  \item Computers are designed to behave like (discrete-state)
    mathematical objects \pause
    \begin{itemize}
    \item when they don't, the ``hardware contract'' has been broken
    \end{itemize}
    \pause
    \medskip
  \item Programming languages can be described mathematically
    \medskip
    \pause
  \item More, high-level programming languages can be described
    \emph{abstractly}, in a high-level way
    \begin{itemize}
    \item without requiring the description of a translation to machine
      code
    \item will describe how this is done when I describe {\structcol ``How?''}
    \end{itemize}
  \end{itemize}

}

\frame{
  \frametitle{Advantages of Formal Contracts}

  Mathematical methods can be used to determine exactly what a
  language guarantees/requires.

  \bigskip\bigskip
  A rigorous understanding of a language can motivate definition of
  {\red language subsets}.  (E.g., MISRA C)

  \bigskip A formal definition for a language can be the basis for the
  development of powerful {\red static analysis tools}.
}

\frame{
  \frametitle{Static Analysis Tools}

  \begin{itemize}
  \item Many successful tools exist in this domain already, but most
    are
    \begin{itemize}
    \item unsound,
    \item incomplete, and
    \item can only be used to find bugs, not to
      provide much certainty about correctness
    \end{itemize}

    \bigskip
  \item Full program verification: the ultimate static analysis.

    But
    \begin{itemize}
    \item retrospective program verification is impossible
    \item reliability must be built in from the outset
    \item formality is needed in the specification as well as the
      description of the implementation language
    \end{itemize}

  \end{itemize}

}

\frame{
  \frametitle{One Possible Static Analysis Scenario}

\psset{unit=1mm,linewidth=.1mm}
\begin{pspicture}(120,70)
% high-level source
\rput(0,-2.5){
  \psframe[shadow=true,shadowcolor=CornflowerBlue,shadowsize=1pt,framearc=.2,linecolor=blue](0,70)(40,35)
  \rput(20,63){\parbox{3cm}{\centering \blue High-level Source\\(Spec)}}
  \psset{linecolor=blue,linestyle=dotted,linewidth=.2mm}
  \rput(0,-5){
    \psline(5,60)(35,60)
    \psline(5,55)(35,55)
    \psline(5,50)(35,50)
    \psline(5,45)(35,45)
  }
}
% low-level code
\rput(0,0){
  \psframe[shadow=true,framearc=0,linecolor=Brown](80,70)(120,30)
  \rput(100,65){\textcolor{Brown}{\texttt{Low-level Code}}}
  \psset{linecolor=Brown,linestyle=dotted,linewidth=.2mm}
  \rput(80,-5){
    \psline(5,60)(35,60)
    \psline(5,55)(35,55)
    \psline(5,50)(35,50)
    \psline(5,45)(35,45)
    \psline(5,40)(35,40)
  }
}
% down left
\pscurve[linecolor=blue,linewidth=1.25]{->}(20,32.5)(25,22)(50,18)(55,15)
% down right
\pscurve[linecolor=Brown,linewidth=1.25]{->}(100,30)(95,22)(70,18)(65,15)
% translation arrow
\rput(0,0){
  \psline[linewidth=.8]{->}(40,50)(80,50)
  \rput(60,55){\psovalbox[fillcolor=CornflowerBlue,fillstyle=solid,linestyle=none]{\textbf{Translation}}}
}
\rput(60,10){\parbox{4cm}{\centering Verification\\(Equivalence Check)}}
\end{pspicture}

The translation might be done by a third-party tool, but rigorous
descriptions of source and target languages are required.

}

\frame{
  \frametitle{Why C++ ?}

C++
\begin{itemize}
\item is a popular object-oriented application-level language
\item provides higher-level abstractions than C
\item \dots while still compiling to efficient code
\item high-level abstractions can lead to cleaner/safer/more reliable implementations
\end{itemize}

}

\frame{
  \frametitle{Why Not C++ ?}

}

\section{How?}

\section{What Exactly?}

\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
