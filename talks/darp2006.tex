\documentclass[dvips,xcolor=pst,color=usenames]{beamer}

\usetheme{Madrid}
\usepackage{url}
\usepackage{pstricks}
\usepackage{pst-tree}
\usepackage{pst-node}
\usepackage{proof}
\usepackage{pst-grad}
\usepackage{fancyvrb}

\setbeamertemplate{navigation symbols}{}
\setbeamercolor{math text}{fg=blue}
\newcommand{\structcol}{\usebeamercolor[fg]{structure}}

\title[Formally Defining C++]{Formally Defining C++\\
  Why, How, \& What Exactly}
\author{Michael Norrish}
\institute{National ICT Australia}
\titlegraphic{\includegraphics[width=0.3\textwidth]{nicta-colour-on-pale.eps}}
\date{25 April 2006}

\begin{document}

\frame{\titlepage}

\section*{Introduction}

\frame{
  \frametitle{Outline}
  \tableofcontents
}

\section{Why?}
\subsection{Why Formal Language Description}
\frame{
  \frametitle{Why Describe a Language?}

\textbf{Reason \#1:}

\begin{quote}
To establish a contract between the {\red users} and
{\red implementors} of a language
\end{quote}

\pause
\begin{center}
\begin{tabular}{lp{0.6\textwidth}}
{\structcol Users} & Programmers; those who submit source code to a language
  implementation and expect a particular behaviour in return\\[3mm]
{\structcol Implementors} & Programmers; those who write a language
  implementation which other programmers will feed with source code
\end{tabular}
\end{center}

}

\frame{
  \frametitle{A Language Contract}

{\structcol \bfseries Manages Expectations}

\begin{itemize}
\item Users expect \texttt{\structcol i = i + 1} to add one to
  variable \texttt{\structcol i}

\item Implementors can rely on users not attempting to divide by
  zero (in C/C++ anyway)
\end{itemize}

\pause
\bigskip\bigskip
{\structcol \bfseries Is Not an Implementation}

\begin{itemize}
\item Even for a language like Perl.
  \begin{itemize}
  \item After all, people report bugs
    against Perl implementations.   Something other than the
    implementation is defining what is and is not correct.
  \end{itemize}
\end{itemize}

}

\frame{
  \frametitle{Language Contracts are Written in English}

To wit (ISO/IEC 14882:2003, \S3.5, para 8):
\begin{quote}
\small
Names not covered by these rules have no linkage.  Moreover, except as
noted, a name declared in a local scope (3.3.2) has no linkage.  A
name with no linkage (notably, the name of a class or enumeration
declared in a local scope (3.3.2)) shall not be used to declare an
entity with linkage.  If a declaration uses a typedef name, it is the
linkage of the type name to which the typedef refers that is
considered. [Example: ...] This implies that names with no linkage
cannot be used as template arguments (14.3).
\end{quote}

If the user and the implementor disagree on the meaning of the
contract, how can such a dispute be resolved?

}

\frame{
  \frametitle{Formal Contracts}

  [``Formal'' $=$ ``Mathematical'']

  \medskip
  \begin{itemize}
  \item Mathematical reasoning is a route to certainty
  \item Computers are designed to behave like (discrete-state)
    mathematical objects \pause
    \begin{itemize}
    \item when they don't, the ``hardware contract'' has been broken
    \end{itemize}
    \pause
    \medskip
  \item Programming languages can be described mathematically
    \medskip
    \pause
  \item More, high-level programming languages can be described
    \emph{abstractly}, in a high-level way
    \begin{itemize}
    \item without requiring the description of a translation to machine
      code
    \item will describe how this is done when I describe {\structcol ``How?''}
    \end{itemize}
  \end{itemize}

}

\frame{
  \frametitle{Advantages of Formal Contracts}

  Mathematical methods can be used to determine exactly what a
  language guarantees/requires.

  \bigskip\bigskip
  A rigorous understanding of a language can motivate definition of
  {\red language subsets}.  (E.g., MISRA C)

  \bigskip A formal definition for a language can be the basis for the
  development of powerful {\red static analysis tools}.
}

\frame{
  \frametitle{Static Analysis Tools}

  \begin{itemize}
  \item Many successful tools exist in this domain already, but most
    are
    \begin{itemize}
    \item unsound,
    \item incomplete, and
    \item can only be used to find bugs, not to
      provide much certainty about correctness
    \end{itemize}

    \bigskip
  \item Full program verification: the ultimate static analysis.

    But
    \begin{itemize}
    \item retrospective program verification is impossible
    \item reliability must be built in from the outset
    \item formality is needed in the specification as well as the
      description of the implementation language
    \end{itemize}

  \end{itemize}

}

\frame{
  \frametitle{One Possible Static Analysis Scenario}

\psset{unit=1mm,linewidth=.1mm}
\begin{pspicture}(120,70)
\psframe[fillstyle=solid,fillcolor=yellow!15!white,linestyle=none](-2,71)(122,0)
% high-level source
\rput(0,-2.5){
  \psframe[framearc=.2,linecolor=blue,linewidth=.2mm,fillstyle=solid,fillcolor=white](0,70)(40,35)
  \rput(20,63){\parbox{3cm}{\centering \blue High-level Source\\(Spec)}}
  \psset{linecolor=blue,linestyle=dotted,linewidth=.2mm}
  \rput(0,-5){
    \psline(5,60)(35,60)
    \psline(5,55)(35,55)
    \psline(5,50)(35,50)
    \psline(5,45)(35,45)
  }
}
% low-level code
\rput(0,0){
  \psframe[shadow=true,framearc=0,linecolor=Brown](80,70)(120,30)
  \rput(100,65){\textcolor{Brown}{\texttt{Low-level Code}}}
  \psset{linecolor=Brown,linestyle=dotted,linewidth=.2mm}
  \rput(80,-5){
    \psline(5,60)(35,60)
    \psline(5,55)(35,55)
    \psline(5,50)(35,50)
    \psline(5,45)(35,45)
    \psline(5,40)(35,40)
  }
}
% down left
\pscurve[linecolor=blue,linewidth=1.25]{->}(20,32.5)(25,22)(50,18)(55,15)
% down right
\pscurve[linecolor=Brown,linewidth=1.25]{->}(100,30)(95,22)(70,18)(65,15)
% translation arrow
\rput(0,0){
  \psline[linewidth=.8]{->}(40,50)(80,50)
  \rput(60,55){\psovalbox[fillcolor=CornflowerBlue,fillstyle=solid,linestyle=none]{\textbf{Translation}}}
}
\rput(60,10){\parbox{4cm}{\centering Verification\\(Equivalence Check)}}
\end{pspicture}

The translation might be done by a third-party tool, but rigorous
descriptions of source and target languages are required.

}


\subsection{Why C++}
\frame{
  \frametitle{Why C++ ?}

C++
\begin{itemize}
\item is a popular object-oriented application-level language
\item provides higher-level abstractions than C
\item \dots while still compiling to efficient code
\item high-level abstractions can lead to cleaner/safer/more reliable implementations
\end{itemize}

}

\frame{
  \frametitle{C++ Features}

  \begin{itemize}
  \item \textbf{Inheritance} (multiple, public and private), giving
    \begin{itemize}
    \item \textbf{Sub-class polymorphism} (cats behave like mammals,
      like animals)
    \end{itemize}
  \item \textbf{Parametric Polymorphism} (templates, ``generic code'')
  \item \textbf{Function Overloading} (functions of the same name with
    different types)
  \item \textbf{Exceptions}
  \item \textbf{Hierarchical Name-spaces}
  \end{itemize}


}

\frame{
  \frametitle{Why Not Formalise C++ ?}

(See previous slide\dots)

\bigskip
Semantic complexity of many interacting features is intimidating.
\begin{itemize}
\item ``No-one knows all of C++''
\end{itemize}

\bigskip
How would one know that a formal semantics was correct?
\begin{itemize}
\item Indeed, what does \emph{correctness} mean here?
\end{itemize}

}

\section{How?}

\frame{
  \frametitle{How?}
\tableofcontents[current]
}
\subsection{Operational Semantics---Simple Examples}
\frame{
  \frametitle{Operational Semantics}

I propose to write a formal description of C++ using the technique
known as operational semantics.

\bigskip This can been seen as
\begin{quote}
\structcol writing an interpreter in logic
\end{quote}

\pause\bigskip This is an interpreter that can use the full (not
necessarily executable) expressive-ness of logic and mathematics
(sets, quantifiers, functions \dots).

\medskip It can
\begin{itemize}
\item model under-specification
\item model non-determinism
\end{itemize}

}

\frame{
  \frametitle{Operational Semantics---Generalities}

An operational definition typically is a set of rules of the form
\[
\infer{\mathit{start} \rightarrow \mathit{result}}{
    \mathit{premiss}_1 &
    \cdots &
    \mathit{premiss}_n}
\]
meaning
\begin{quote}
\structcol
If the premisses hold then it is the case that $\mathit{start}$ can
become/evolve~to/evaluate~to $\mathit{result}$.
\end{quote}

\bigskip
(Use of {\structcol can} rather than {\structcol must} above allows
for non-determinism.)
}

\frame{
  \frametitle{Operational Semantics---Example Rules}

Rules for $\textsf{if}$:
\[
\begin{array}{c}
\infer{\textsf{if}\;G\;\textsf{then}\;e_1\;\textsf{else}\;e_2
  \;\,\rightarrow\,\; v_1}{
  G \;\,\rightarrow\;\,\textsf{True} &&
  e_1 \;\,\rightarrow\;\,v_1
}\\[1cm]
\infer{\textsf{if}\;G\;\textsf{then}\;e_1\;\textsf{else}\;e_2
  \;\,\rightarrow\,\; v_2}{
  G \;\,\rightarrow\;\,\textsf{False} &&
  e_2 \;\,\rightarrow\;\,v_2
}
\end{array}
\]

These are fine for $\textsf{if}$-expressions that do not have side
effects.


}

\subsection{C: Witness to Practicality}

\subsection{Probable Approaches}

\section{What Exactly?}

\end{document}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
