Imagine the code looks like

----------------------------------------------------------------------
class B1 {
  int Bfld;
public:
  B1(int n) : Bfld(n) {}
};

struct B2 { int x; int y; };

class VB {
  int vfld1;
  int vfld2;
protected:
  VB(int n) { vfld1 = vfld2 = n; }
};

class D1 : public B1, public B2, virtual public VB {
  int d1;
protected:
  D1() : B1(1), VB(4) { d1 = 3; }
};

class D2 : virtual public VB {
  int d2;
protected:
  D2(int x, int y) : VB(x + y), d2(x - y) { }
};

class Final : public D1, public D2 {
public:
  int f;
  Final(char c) : VB(c + 1), D2(6,4) { f = 7; }
};

int main()
{
  Final f('d');
}

----------------------------------------------------------------------

First, we have

  VDecInit (Class "Final") "f" (DirectInit0 ['d'])

where the zero is the place-holder address for a constructor that
hasn't been given any memory to work with yet.

Next decl-vdecinit-start-evaluate-direct-class fires and allocates
space for the variable, at address a, giving us

  VDecInitA (Class "Final") a
            (DirectInit (FnApp (ConstructorFVal T a "Final") ['d']))

The T argument to ConstructorFVal indicates that this is a
most-derived class.  Then evaluation of the expression under the
DirectInit will take place, using decl-vdecinit-evaluation as many
times as necessary.

So, what happens with

   FnApp (ConstructorFVal T a "Final") ['d']

First the argument will be evaluated, and then a seqpt tag added to
the FnApp constructor to move us to

  FnApp_sqpt (ConstructorFVal T a "Final") [dval]

Then the rule constructor-function-call fires.  It looks up the
constructor information, getting a constructor body, the parameter
information and the list of mem-initialisors.  Then the
construct_ctor_body function is called to add extra declarations to
the front of the body.  These handle the mem-initialisors and any
non-static data members.

In this case, there are three base classes, and one nsd-member.  The
nsd-member (field "f") is not initialised (see 12.6.2 p4, case 2), so
there are just three new declarations added.

  VDecInitA (Class "VB") (a + vb_offset)
            (DirectInit (FnApp (ConstructorFVal F (a + vb_offset) "VB")
                               [c + 1]))

  VDecInitA (Class "D1") (a + d1_offset)
            (DirectInit (FnApp (ConstructorFVal F (a + d1_offset) "D1")
                               []))

  VDecInitA (Class "D2") (a + d2_offset)
            (DirectInit (FnApp (ConstructorFVal F (a + d2_offset) "D1")
                               [6,4]))

These declarations will be evaluated in a context where the enclosing
"Final" constructor's parameter c has been put in scope.  Because
there was never a name associated with these declarations (i.e., they
didn't pass through the VDecInit stage), their initialisation won't
affect the varmap.  However, these classes are all non-most-derived,
and the F flag as first argument to ConstructorFVal indicates this.



