@inproceedings{wasserrab-nst-OOPSLA06,
  author={Daniel Wasserrab and Tobias Nipkow and Gregor Snelting and Frank Tip},
  title={An Operational Semantics and Type Safety Proof for Multiple
         Inheritance in {C}++},
  booktitle={{OOPSLA}~'06: Object oriented programming, systems, languages,
             and applications},
  publisher={ACM Press},
  year=2006,
  note = {Available from \url{http://isabelle.in.tum.de/~nipkow/pubs/oopsla06.html}},
  annote =

   "This article describes an elegant method of modelling multiple
                  inheritance in C++, without having to explicitly
                  describe the construction of vtables.  Instead,
                  references to objects are accompanied by \emph{paths},
                  allowing one to simultaneously identify the static
                  and dynamic type of an object.\\[1ex]

    The article very carefully lays out the way polymorphic names
                  (those associated with \texttt{virtual} functions)
                  are resolved at run-time, referring to objects'
                  dynamic and static types.  "

}

@inproceedings{netsem:popl2006,
 author = {Steve Bishop and Matthew Fairbairn and Michael Norrish and
           Peter Sewell and Michael Smith and Keith Wansbrough},
 title = {Engineering with logic: {HOL} specification and symbolic-evaluation
          testing for {TCP} implementations},
 booktitle = {POPL'06: Conference record of the 33rd ACM SIGPLAN-SIGACT
              symposium on Principles of programming languages},
 year = {2006},
 isbn = {1-59593-027-2},
 pages = {55--66},
 location = {Charleston, South Carolina, USA},
 doi = {http://doi.acm.org/10.1145/1111037.1111043},
 publisher = {ACM Press},
 address = {New York, NY, USA},
annote = "This article is relevant to C++ only inasmuch as it suggests
                  a technique that might allow reasonably efficient
                  evaluation of a branching, non-deterministic
                  operational semantics."
 }

@Manual{cpp-standard-iso14882,
  title =        {Programming Languages---C++},
  key =          {ISO/IEC 14882},
  year =         2003,
  note =         {ISO/IEC 14882:2003(E)},
  annote =       "The canonical reference for all of the semantics,
                  this is the latest official ISO standard."
}

@inproceedings{DBLP:conf/ecoop/SiekT06,
  author    = {Jeremy Siek and
               Walid Taha},
  title     = {A Semantic Analysis of {C+$\!$+} Templates.},
  booktitle = {ECOOP},
  year      = 2006,
  pages     = {304-327},
  ee        = {http://dx.doi.org/10.1007/11785477_19},
  crossref  = {DBLP:conf/ecoop/2006},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  annote =    "A elegant, though somewhat simplistic, presentation of
                  template instantiation in \cpp.  Discussed in
                  Section~\ref{sec:templates}. "
}

@proceedings{DBLP:conf/ecoop/2006,
  editor    = {Dave Thomas},
  title     = {ECOOP 2006 - Object-Oriented Programming, 20th European
               Conference, Nantes, France, July 3-7, 2006, Proceedings},
  booktitle = {ECOOP},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  volume    = {4067},
  year      = {2006},
  isbn      = {3-540-35726-2},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@PhdThesis{Norrish98,
  author =       {Michael Norrish},
  title =        {{C} formalised in {HOL}},
  school =       {Computer Laboratory, University of Cambridge},
  year =         1998,
  note =         {Also published as Technical Report 453, available from \url{ht
tp://www.cl.cam.ac.uk/TechReports/UCAM-CL-TR-453.pdf}},
  annote =       "The starting point for the \cpp{} mechanisation.
                  This semantics for C has an awkward treatment of
                  statements, attempting to give statements a big-step
                  semantics at the same time as expressions are
                  evaluated in a small-step style.  The new statement
                  model for \cpp{} is described in
                  Section~\ref{sec:small-step-stmts}. The thesis's
                  treatment of the sequence point rule allowing
                  references to variables that are to be updated is
                  also rather complicated.  In preference, Clive
                  Feather's semantics has been adopted for the \cpp{}
                  model (see the discussion of assignment in
                  Section~\ref{sec:assignment} on
                  page~\pageref{sec:assignment})."
}

@Misc{Feather2000,
  author =    {Clive Feather},
  title =     {A Formal Model of Sequence Points and Related Issues: Working Draft},
  howpublished = {ISO Standards Document JTC1/SC22/WG14 N925},
  month =     {September},
  year =      2000,
  note =      {Available at
                  \url{http://www.open-std.org/jtc1/sc22/wg14/www/docs/n925.htm}},
  annote =    "This proposal gives a rigorous description of how C's
                  expression evaluation should work, with particular
                  reference to the possible undefinedness of
                  expressions caused by the sequence point rules."
}

@Manual{HOLdescription,
  key =   {HOL},
  title =        {The HOL System: Description},
  year =      2007,
  note =      {Available at \url{http://hol.sourceforge.net}},
  annote = "A complete description of the HOL4 system, with details
                  about its ML implementation, as well as its logical
                  theories."
}

@Book{Stroustrup1994:DECPP,
  author =    {Bjarne Stroustrup},
  title =        {The Design and Evolution of \cpp},
  publisher =    {Addison-Wesley},
  year =         1994,
  annote =    "A description of the history of \cpp's
                  development. Some of the discussion is quite useful
                  in describing why certain features of the language
                  are the way they are."
}


@Book{Stroustrup2000:TCPL,
  author =    {Bjarne Stroustrup},
  title =        {The \cpp{} Programming Language},
  publisher =    {Addison-Wesley},
  year =         2006,
  edition =   {2nd},
  annote =    "A very complete introduction to \cpp, explaining how to
                  use the language effectively and in a principled
                  way.  Detailed, ISO~standard style discussion of
                  semantics is present haphazardly."
}

@Book{Paulson:ML,
  author =    {Lawrence C. Paulson},
  title =        {{ML} for the Working Programmer},
  publisher =    {Cambridge University Press},
  year =         1996,
  edition =   {2nd},
  annote =    "An introductory textbook describing the functional
                  programming language SML.  Logical specifications in
                  HOL often resemble functional programs.
                  Additionally, many of the functions used in HOL
                  theories have counterparts in SML.  (SML is commonly
                  known as ``ML''.)"
}

@Book{Gordon93,
 editor = "M. J. C. Gordon and T. Melham",
 title = "Introduction to {HOL}: a theorem proving environment for higher order logic",
 publisher = "Cambridge University Press",
 year = 1993,
 annote = "This book is the ancestor to~\cite{HOLdescription}; it is a
                  complete description, including much reference
                  material, for the (now outdated) HOL88 system."
}

@TechReport{Rushby93,
  author =       {John Rushby},
  title =        {Formal methods and the certification of critical systems},
  institution =  {Computer Science Laboratory, {SRI} International},
  year =         {1993},
  number =       {CSL-93-7},
  address =      {Menlo Park, CA 94025, USA},
  month =        {November},
  note =         "Available at \url{http://www.csl.sri.com/papers/csl-93-7/}",
  annote =       "A well-written introduction to the nature and use of
                  ``formal methods'' at a variety of levels (ranging
                  from ``no use of FM'' to ``full use of mechanically
                  checked proofs'').  Rushby introduces the notion of
                  \emph{formal challenge} to a specification, which
                  corresponds to what Section~\ref{sec:validation}
                  calls a ``sanity theorem''. \\[1ex] Rushby's \S2.3
                  discusses validation of formal specifications
                  generally.  Because HOL, cited by Rushby, uses the
                  definitional approach everywhere, ``internal
                  consistency'' is easy to establish in the context of
                  this \cpp{} project. On the other hand, what Rushby
                  calls ``external fidelity'' (\S2.3.2) is much
                  harder, and is validation in the sense: ``the
                  specification means what we
                  want/expect/think''.\\[1ex] Rushby's \S3 includes an
                  exhaustive, and by no means out-dated, check-list of
                  features that formal methods tools should exhibit if
                  they are to be practically useful in large
                  verification projects. "
}
