\documentclass[11pt]{article}

\usepackage{charter}
\usepackage{alltt}
\usepackage{url}
\usepackage{proof}

\title{Notes on Deliverable 2 (August 2006)}
\author{Michael Norrish\\{\small \texttt{Michael.Norrish@nicta.com.au}}}
\date{}

\newcommand{\cpp}{\mbox{C\hspace{-0.5pt}+\hspace{-1.5pt}+}}

\begin{document}
\maketitle

\section{Form}

This deliverable consists of a compressed \texttt{tar}-file, that when
unpacked consists of a directory called \texttt{qinetiq-cpp}, which in
turn contains three directories
\begin{itemize}
\item \texttt{holsrcs}, containing the HOL source files of the
  mechanisation.  These files will build with the version of HOL4
  present in the CVS repository at SourceForge, with timestamp
  \texttt{2006-07-31 00:00Z}.  See Section~\ref{sec:getting-hol}
  below for instructions on how this version of HOL can be retrieved,
  and how the deliverable's HOL source files can then be built and
  checked.
\item \texttt{talks}, containing the \LaTeX{} source and a PDF for the
  talk presented at the DARP meeting in Newcastle in April 2006.  The
  source assumes that the \texttt{latex-beamer} and \texttt{PSTricks}
  packages are available.
\item \texttt{docs}, containing \LaTeX{} sources and a PDF version of
  this document, as well as sources for the notes on Deliverable~1.
\item \texttt{notes}, some C++ source files that illustrate various
  aspects of C++ behaviour.  An accompanying text file explains some
  of the behaviours.
\end{itemize}

\subsection{Building HOL Source-Files}
\label{sec:getting-hol}

\paragraph{Getting HOL From SourceForge}

To get a particular, dated, version of the HOL4 sources from the CVS
repository, one must first issue the command

{\small
\begin{verbatim}
   cvs -d:pserver:anonymous@hol.cvs.sourceforge.net:/cvsroot/hol login
\end{verbatim}
}

When prompted for a password, just press \texttt{Enter} to send a null
response.  The check-out of source code from SourceForge can now
proceed.  The source code fits into 60MB.  Issue the command

{\small
\begin{alltt}
   cvs \textit{repository-spec} co -D \textit{date} hol98
\end{alltt}
}

\noindent where \textit{\ttfamily repository-spec} is the string

{\small
\begin{alltt}
   -d:pserver:anonymous@hol.cvs.sourceforge.net:/cvsroot/hol
\end{alltt}
}

\noindent (also used in the \texttt{login} command), and where
\textit{\ttfamily date} is the desired date, best specified as an
ISO~8601 string enclosed in double-quotes.  For example,
\texttt{"2006-06-30 04:05Z"}.

Once a copy of the sources have been downloaded, further commands can
be used to update this copy to correspond to different dates.  As long
as such commands are issued from within the \texttt{hol98} directory,
the repository specification can be omitted.  The update command is

{\small
\begin{alltt}
   cvs update -d -D \textit{date}
\end{alltt}
}

\paragraph{Installing HOL} Once the sources have been downloaded, the
installation instructions from the page at
\url{http://hol.sourceforge.net} should be followed to build a copy of
HOL.  An installation of the Moscow~ML compiler (v2.01) will also be
required.

\paragraph{Building Deliverable Sources}
When HOL4 has been installed, the \texttt{Holmake} program (found in
the \texttt{hol98/bin} directory) can be run in the \texttt{holsrcs}
directory to create and check the logical theories.

\section{Content}

This deliverable delivers a HOL semantics for a ``\cpp-like''
language.  In accordance with the statement of work, it provides
``basic object-orientation (dynamic dispatch, inheritance) and
reference types''.  Object-orientation is discussed in
Section~\ref{sec:basic-oo} below, while reference types are discussed
in Section~\ref{sec:reftypes}.  Some preliminary work on validation
technology is discussed in Section~\ref{sec:validation}.

\subsection{Basic Object-Orientation}
\label{sec:basic-oo}

The inspiration for this part of the semantics is the article by
Wasserrab~\emph{et al}~\cite{wasserrab-nst-OOPSLA06}, which provides a
detailed model for multiple inheritance.  For the moment, my model
doesn't handle multiple inheritance, but I have nonetheless adopted
much of this article's basic technology as it certainly handles the
single-inheritance situation.

\paragraph{Class Declaration}
A class declaration is similar to the C model's declaration of a
\texttt{struct} type.  A class declaration takes two parameters, the
name of the class, and an optional ``class-info''
argument.\footnote{The information argument is optional to allow the
  situation where a forward declaration of a class occurs.}  The
class-info, if present, is a list of fields, coupled with an optional
ancestor class.  The latter allows single-inheritance.  The fields are
of two sorts, ``data'' fields or function definitions.  (A field
declaration of a function, though strictly not data, emulates the
situation where a member function is declared elsewhere.)  Both sorts
of fields are accompanied by a flag indicating whether or not they are
static, and a protection indicator (i.e., \texttt{public},
\texttt{protected}, or \texttt{private}).  For the moment, both
static-ness and protection information is entirely ignored, so that
all members are assumed to be \texttt{public} and non-static.

Member function definitions give the function's name, return-type,
parameter list (types and names), and function body.  This is a close
match for the abstract syntax.  All functions are assumed to be
virtual.

When a class declaration is encountered (only at the top-level;
neither nested or local classes are supported yet), its member
functions are entered into the state's function map.  The same
function map is used for normal (non-class) functions, so there is a
type of ``function-id'', declared
\begin{verbatim}
   fnid = GlobalFn of string | MFn of string => string
\end{verbatim}
meaning that such an identifier can be either global, in which case it
is given by one string (the function's name); or it can be a member
function, in which case it is given by a pair of strings: the class's
name and the function's name.

\paragraph{Class Values}
There is no support for classes as r-values in the semantics as yet.
Instead, all expressions of class-type must be l-values.  This
restriction is based on the problems that will arise when multiple
inheritance is implemented.  In particular, with multiple inheritance
in place, it is no longer true that one can extract the byte sequence
for a given l-value by starting at the base address and taking as many
bytes from memory as the size of the type.  In particular, virtual
base classes may be at completely different places in memory, not
necessarily even contiguous with the rest of the object.  (This is
demonstrated for the \texttt{g++} compiler by the little program in
\texttt{notes/mult-inheritance-layout.cpp}.)

Absence of support for r-values means that, in this model, one can not
assign classes, pass them as parameters, or return them from
functions.  However, because references are supported (see below) much
idiomatic \cpp{} is supported.

The presence of classes means that the model's presentation of
l-values changes from the way it was in the original C model.  In
particular, an l-value that is statically typed as a base class needs
to know dynamically that it is really of a derived type.  This
information is traditionally recorded in \texttt{vtable} fields.
Following Wasserrab~\emph{et al}, my model instead records an
additional path accompanying every l-value.  This path is a list of
strings, listing the path through the ancestry-tree that leads from
the most-derived class to the current class type.

Consider, for example, the code in Figure~\ref{fig:oo-example}.  The
body of function \texttt{g} constructs the l-value \texttt{*b} when it
calls \texttt{f}.  As in the C model, this l-value will be associated
with some address, and the static type, which is \texttt{Class~B}.
But the additional path information that accompanies the l-value will
be the list \texttt{[D,B]}.  The last element of such paths is always
the static class type.  The prefix of the list makes it clear that
this is a \texttt{B} l-value that is dynamically a \texttt{D}.  And
when field selection occurs, the \texttt{f} chosen will be
\texttt{D}'s.

\begin{figure}[hbtp]
\begin{verbatim}
   class B {
   public:
     virtual int f() { return 3; }
   };

   class D : public B {
   public:
     int f() { return 4; }
   };

   int g(class B *b)
   {
     return b->f();
   }

   int main()
   {
     D d;
     return g(&d);
   }
\end{verbatim}
\caption{C++ code demonstrating OO-polymorphism; the program will
  return 4, though it appears as if \texttt{B}'s function \texttt{f}
  is called.}
\label{fig:oo-example}
\end{figure}


\paragraph{Field Selection}
Following Wasserrab~\emph{et al}, field selection is based on the
notion of being able to find the most-derived declaration of the given
field in the ancestor hierarchy above the current dynamic type


\subsection{Reference Types}
\label{sec:reftypes}


\subsection{Validation}
\label{sec:validation}

\section{Future}

\bibliographystyle{plain}
\bibliography{deliverables}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

